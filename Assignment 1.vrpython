{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\nmyVariable = 0\nGRID = 250\n\nfrom vexcode import *\n\n# def go_to(x_loc, y_loc):\n#     b = x_loc - location.position(X,MM)\n#     c = y_loc - location.position(Y,MM)\n\n#     if b == 0 and c == 0:\n#         pass\n#     else:\n#         a = math.sqrt(b**2 + c**2)\n#         angle = math.asin((math.sin(math.pi/2) * b) / a) / math.pi * 180\n\n#         if b > -1 and c < 0 or b < 0 and c < 0:\n#             drivetrain.turn_to_heading((180 - angle), DEGREES)\n#         else:\n#             drivetrain.turn_to_heading(angle, DEGREES)\n        \n#         drivetrain.drive_for(FORWARD, a, MM)\n\n# def go_to(x_loc, y_loc):\n#     b = x_loc - location.position(X,MM)\n#     c = y_loc - location.position(Y,MM)\n\n#     if b == 0 and c == 0:\n#         return\n\n#     a = math.sqrt(b**2 + c**2)\n\n#     angle = math.degrees(math.atan2(b, c))\n#     drivetrain.turn_to_heading(angle, DEGREES)\n#     drivetrain.drive_for(FORWARD, a, MM)\n\ndef build_shortest_path(path):\n    cleaned = remove_duplicates(path)\n    return remove_loops(cleaned)\n\n\ndef snap(value):\n    return round(value / GRID) * GRID\n\ndef snap_heading(angle):\n    return round(angle / 90) * 90\n\n\n# def go_to(x_loc, y_loc):\n#     b = x_loc - location.position(X,MM)\n#     c = y_loc - location.position(Y,MM)\n\n#     if b == 0 and c == 0:\n#         return\n\n#     distance = math.sqrt(b**2 + c**2)\n#     # angle = math.degrees(math.atan2(b, c))\n\n#     # drivetrain.turn_to_heading(angle, DEGREES)\n\n#     raw_angle = math.degrees(math.atan2(b, c))\n#     angle = snap_heading(raw_angle)\n\n#     drivetrain.turn_to_heading(angle, DEGREES)\n#     drivetrain.drive_for(FORWARD, distance, MM)\n\ndef go_to(x_loc, y_loc):\n    # b = x_loc - location.position(X,MM)\n    # c = y_loc - location.position(Y,MM)\n\n    current_x = snap(location.position(X,MM))\n    current_y = snap(location.position(Y,MM))\n\n    b = x_loc - current_x\n    c = y_loc - current_y\n\n    if b == 0 and c == 0:\n        return\n\n    raw_angle = math.degrees(math.atan2(b, c))\n    angle = snap_heading(raw_angle)\n\n    distance = snap(math.sqrt(b**2 + c**2))\n\n    drivetrain.turn_to_heading(angle, DEGREES)\n    drivetrain.drive_for(FORWARD, distance, MM)\n\ndef expand_path(path):\n    expanded = []\n\n    for i in range(len(path)-1):\n        x1, y1 = path[i]\n        x2, y2 = path[i+1]\n\n        expanded.append([x1, y1])\n\n        dx = x2 - x1\n        dy = y2 - y1\n\n        steps = int((abs(dx) + abs(dy)) / GRID)\n\n        step_x = 0 if dx == 0 else (GRID if dx > 0 else -GRID)\n        step_y = 0 if dy == 0 else (GRID if dy > 0 else -GRID)\n\n        for _ in range(steps-1):\n            x1 += step_x\n            y1 += step_y\n            expanded.append([x1, y1])\n\n    expanded.append(path[-1])\n    return expanded\n\ndef remove_duplicates(path):\n    cleaned = []\n    for p in path:\n        if len(cleaned) == 0 or p != cleaned[-1]:\n            cleaned.append(p)\n    return cleaned\n\n\n# Remove loops (extract shortest path)\n# def remove_loops(path):\n#     stack = []\n#     visited = {}\n\n#     for p in path:\n#         key = tuple(p)\n\n#         if key in visited:\n#             index = visited[key]\n#             stack = stack[:index+1]\n#             visited = {tuple(v): i for i, v in enumerate(stack)}\n#         else:\n#             stack.append(p)\n#             visited[key] = len(stack)-1\n\n#     return stack\n\ndef remove_loops(path):\n    stack = []\n    visited = set()\n\n    for p in path:\n        if p in stack:\n            index = stack.index(p)\n            stack = stack[:index+1]\n        else:\n            stack.append(p)\n\n    return stack\n\n\n\ndef when_started1():\n    global myVariable\n    pass\n\n    location_log_list = []\n\n    drivetrain.set_drive_velocity(100,PERCENT)\n    drivetrain.set_turn_velocity(100,PERCENT)\n    drivetrain.turn_to_rotation(90,DEGREES)\n\n    # location_log_list.append([location.position(X,MM),location.position(Y,MM)])\n\n    new_point = [location.position(X,MM), location.position(Y,MM)]\n\n    if len(location_log_list) == 0 or new_point != location_log_list[-1]:\n        # location_log_list.append(new_point)\n        x = snap(location.position(X,MM))\n        y = snap(location.position(Y,MM))\n        location_log_list.append([x, y])\n\n    # brain.print(location_log_list)\n\n    while not down_eye.detect(RED):\n        if front_distance.get_distance(MM) > 260:\n            drivetrain.drive_for(FORWARD, 250, MM)\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n            # if location_log_list[len(location_log_list) - 2][0] < location.position(X, MM) + 5 and location_log_list[len(location_log_list) - 2][0] > location.position(Y,MM):\n            #     # location_log_list.pop()\n            #     # location_log_list.pop()\n\n            # location_log_list.append([location.position(X,MM),location.position(Y,MM)])\n            x = snap(location.position(X,MM))\n            y = snap(location.position(Y,MM))\n            location_log_list.append([x, y])\n\n            brain.clear()\n            brain.print(location_log_list)\n            # brain.print(location_log_list) # need to move this as its re printing the list out each time. bit annoying to read\n        else:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n        wait(5,MSEC)\n\n    # drivetrain.turn_for(RIGHT, 720, DEGREES)\n    # brain.clear()\n    # brain.print(location_log_list)\n\n    # while True:\n    #     pen.set_pen_color(GREEN)\n    #     pen.move(DOWN)\n    #     location_log_list.reverse()\n\n    #     for i in range(len(location_log_list)):\n    #         go_to(location_log_list[i][0],location_log_list[i][1])\n\n    # cleaned = remove_duplicates(location_log_list)\n    # shortest_path = remove_loops(cleaned)\n\n    # shortest_path = build_shortest_path(location_log_list)\n    # return_path = shortest_path[::-1]   # back to start\n\n    shortest_path = build_shortest_path(location_log_list)\n    shortest_path = expand_path(shortest_path)\n    return_path = shortest_path[::-1]\n    forward_path = shortest_path[1:]\n\n\n    # while True:\n\n    #     pen.set_pen_color(GREEN)\n    #     pen.move(DOWN)\n\n    #     # Go back to start\n    #     for p in return_path:\n    #         go_to(p[0], p[1])\n\n    #     wait(500, MSEC)\n\n    #     # Go back to exit\n    #     for p in shortest_path:\n    #         go_to(p[0], p[1])\n\n    while True:\n\n        pen.set_pen_color(GREEN)\n        pen.move(DOWN)\n\n        # Go back to start\n        for p in return_path:\n            go_to(p[0], p[1])\n\n        wait(500, MSEC)\n\n        # Go back to exit\n        for p in forward_path:\n            go_to(p[0], p[1])\n\n\n\nvr_thread(when_started1)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}